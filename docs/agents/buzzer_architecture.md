# 早押し機連携アーキテクチャ設計

## 概要

USB接続の早押し機（シリアル通信デバイス）を利用し、得点表示画面において誰がボタンを押したかをリアルタイム表示する機能の設計。

## 前提条件

- 得点表示は1台・1タブ運用
- 押下情報は演出表示のみに使用（公式記録には使わない）
- ブラウザはChrome（Chromium系）に固定

## ウィンドウ構成

2つのウィンドウに役割を分離する。

| ウィンドウ | 表示場所 | 役割 |
|---|---|---|
| **制御ウィンドウ** | 操作者のPC画面 | シリアル読み取り・エミュレータUI・ボタン席割り当て設定 |
| **スコアボードウィンドウ** | TV・プロジェクタ | 純粋な表示専用 |

## 物理構成

```
[USB早押し機] ─ シリアル通信 ─ [ローカルPC]
                                 ├── 制御ウィンドウ（操作者用）
                                 ├── スコアボードウィンドウ（TV・プロジェクタ表示）
                                 └── インターネット経由 ─ [VPS: Railsサーバ]
```

## データフロー

### ボタン押下表示（新規）

ボタンID→席IDの変換は制御ウィンドウで行い、席IDのみをスコアボードへ送信する。
スコアボードはボタン番号を一切知らない。

```
[USB早押し機]
     │ シリアル通信（ボタンID）
     ▼
[制御ウィンドウ: Web Serial API]       [エミュレータUI]
     │                                       │
     └──────────────┬────────────────────────┘
                    │ ボタンID
                    ▼
           localStorageのマッピングを参照
                    │ 席番号・0-indexed（未割当の場合は無視）
                    ▼
           BroadcastChannel で送信
                    │
                    ▼
     [スコアボードウィンドウ]
                    │ 席IDで data-seat 要素を検索
                    ▼
           該当DOM要素を更新（即時表示）
```

サーバへの通知は不要。表示のみの用途であるため、ネットワークを一切介さない。
BroadcastChannelはローカル端末内の通信のため、レイテンシの心配はない。

### 得点更新（既存・変更なし）

```
[操作画面] → HTTPリクエスト → [Railsサーバ] → ActionCable → [スコアボードウィンドウ]
```

既存の得点更新フローはそのまま維持する。

## シグナルの定義

シグナルはBroadcastChannelで送受信する型として統一する。
`button_pressed` は席IDを持ち、ボタン番号は含まない。

```typescript
type BuzzerSignal =
  | { type: "button_pressed"; seat: number }  // 0-indexed
  | { type: "correct" }
  | { type: "wrong" }
  | { type: "reset" }
```

BroadcastChannelのチャンネル名は `"buzzer"` とし、メッセージの `data` に `BuzzerSignal` を乗せる。

```typescript
// 送信側（制御ウィンドウ）
const channel = new BroadcastChannel("buzzer");
const seat = resolveMapping(buttonId);  // localStorageから解決（0-indexed）
if (seat !== null) {
  channel.postMessage({ type: "button_pressed", seat });
}

// 受信側（スコアボードウィンドウ）
const channel = new BroadcastChannel("buzzer");
channel.onmessage = (e: MessageEvent<BuzzerSignal>) => {
  handleSignal(e.data);
};
```

## ボタン席割り当て設定

### 概要

どのボタン番号がどの席に対応するかは試合ごとに変わるため、制御ウィンドウで設定し、
localStorageに保存する。設定はページ遷移後も保持される。

席は0〜11の12席、ボタンは1〜24の24個。

### localStorageのデータ構造

```typescript
// キー: "buzzerMapping"
// ボタンIDをキー、席番号（0-indexed）を値とする
type BuzzerMapping = {
  [buttonId: number]: number | null;  // 席番号（0-indexed）or null（未割当）
}

// 例: ボタン3が席0、ボタン7が席1に割り当てられている
{
  "3": 0,
  "7": 1,
}
```

割り当てのない buttonId はキー自体を持たない。逆引き（席番号→ボタンID）は上記から都度算出する。

### 設定操作フロー

設定は「席ごとにボタンを覚えさせる」学習モードで行う。

1. 各席の「設定」ボタンを押すと、その席がボタン待ち受け状態になる
2. 最初に押された早押し機ボタンがその席に結び付けられ、待ち受け状態が終了する
3. 「全消去」ボタンを押すと、全ての結び付きが削除される

待ち受け状態中は、シリアル信号をBroadcastChannelへ送信せず、マッピングの登録にのみ使用する。
エミュレータのボタンも同様に待ち受けに反応する。

待ち受け状態は一度に1席のみ有効とする（別の席の「設定」ボタンを押すと、前の待ち受けはキャンセルされる）。

### 設定UIのイメージ

通常状態：

```
┌───────────────────────────────────┐
│ ボタン席割り当て設定  [全消去]    │
│                                   │
│  席 0   ボタン 3   [設定]         │
│  席 1   ボタン 7   [設定]         │
│  席 2   未割当     [設定]         │
│  席 3   未割当     [設定]         │
│  ...                              │
│  席 11  未割当     [設定]         │
└───────────────────────────────────┘
```

席2の「設定」ボタンを押した後（待ち受け状態）：

```
┌───────────────────────────────────┐
│ ボタン席割り当て設定  [全消去]    │
│                                   │
│  席 0   ボタン 3   [設定]         │
│  席 1   ボタン 7   [設定]         │
│  席 2  【ボタンを押してください】  │
│  席 3   未割当     [設定]         │
│  ...                              │
│  席 11  未割当     [設定]         │
└───────────────────────────────────┘
```

早押し機のボタンを押すと即座に登録され、通常状態に戻る。

## エミュレータUI

制御ウィンドウに表示する。実機未接続時の代替として使用する。
エミュレータのボタンも実機と同様に、制御ウィンドウのマッピング処理を経て席IDに変換される。

```
┌─────────────────────────────────────────────────┐
│ 早押し機エミュレータ                             │
│                                                  │
│  [ 1][ 2][ 3][ 4][ 5][ 6]                       │
│  [ 7][ 8][ 9][10][11][12]                        │
│  [13][14][15][16][17][18]                        │
│  [19][20][21][22][23][24]                        │
│                                                  │
│  [  正解  ]  [  誤答  ]  [ リセット ]            │
└─────────────────────────────────────────────────┘
```

## スコアボード側のDOM設計

スコアボードはRailsが返すHTMLに `data-seat` を付与する。
ボタン番号は関知しない。

### ERBテンプレート

```erb
<% seats.each_with_index do |seat, index| %>
  <div class="player-card"
       data-seat="<%= index %>">
    <%= seat.player_name %>
  </div>
<% end %>
```

### Stimulusコントローラ（席番号で要素を検索）

```typescript
private handleSignal(signal: BuzzerSignal): void {
  if (signal.type === "button_pressed") {
    const target = this.element.querySelector(
      `[data-seat="${signal.seat}"]`
    );
    if (target) {
      target.classList.add("is-pressed");
    }
  }
}
```

## 実装上の考慮点

### 自動再接続（制御ウィンドウ）

Web Serial APIはページリロードのたびにユーザ操作による権限再付与が必要だが、Chromeでは `navigator.serial.getPorts()` で過去に許可したポートを自動取得できる。

```typescript
// ページロード時に自動再接続を試みる
const ports = await navigator.serial.getPorts();
if (ports.length > 0) {
  await ports[0].open({ baudRate: 9600 });
  // ユーザ操作なしで再接続できる
}
```

初回のみポートを選択すれば、以降はリロードしても自動接続される。

### 接続状態インジケータ（制御ウィンドウ）

運用中にデバイスが繋がっているかどうかを制御ウィンドウ上で確認できるよう、
簡単なインジケータ（接続中/未接続）を表示する。

### 状態のライフサイクル管理（スコアボードウィンドウ）

2つのデータソース（BroadcastChannel・ActionCable）が同一画面に存在するため、表示の競合に注意する。

例：ボタン押下 → 「Aさんが押した」表示中 → 得点更新（ActionCable）到達

得点更新のタイミングで押下演出をクリアするなど、ライフサイクルをStimulusコントローラ内で管理する。

## 責務の分離

| 機能 | 担当 | 理由 |
|------|------|------|
| シリアル信号の読み取り | 制御ウィンドウ（Web Serial API） | 低レイテンシ必須 |
| ボタンID→席番号の変換 | 制御ウィンドウ（localStorage参照） | マッピングロジックを一箇所に集約 |
| ボタン席割り当て設定UI | 制御ウィンドウ | 操作者が設定・確認しやすい場所 |
| エミュレータUI | 制御ウィンドウ | 実機不在時の代替 |
| 誰がボタンを押したか表示 | スコアボードウィンドウ（BroadcastChannel受信） | 純粋な表示専用 |
| 得点管理・記録 | Railsサーバ | 整合性・永続化が重要 |
| 他クライアントへのスコア同期 | ActionCable | 既存の仕組みを活用 |

## 未確定事項

- シリアル信号のフォーマット（ボーレート、ボタン識別のバイト列）
